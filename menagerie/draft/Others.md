




Part of the problem might be that we don’t really have programming language abstractions that properly include containment.  

Does containment actually exist?  It makes sense to me to say that some software is running inside a JVM on a particular box.  And that the JVM process is contained on that box.  There seems to be a hierarchy of containment here, much like you’d get with geneos.  

Principle Of Locality

Networks and computers break locality. They allow anything to happen anywhere.  But, the human brain (and possibly the universe as a whole) are founded on this principle.  So, abstracting it away means that it becomes an unknowable quantity.  And, lack of observability might follow from this.

Common Taxonomy

This is something you see in the TOM:  the desire to end up with a single way of describing features.  Essentially, we really need a database that explains our software processes.  Building the model of the processes is basically building a database.  But, is there a fixed schema for this, or do you let people figure it out as they go?

schema: could also refer to an XML schema, which obviously, is also a database format.  What happened to XML databases, anyway?

What would this even mean?

Programming languages fail us because they encourage us to build software that is unknowable.  Could we invent a language that fixes this problem?

In the same way as we made Java a language without memory leaks, could we make a language for describing software in a way that makes it eminently knowable?

So far, I have not come across anything that does this.  But that doesn’t mean it’s impossible - just that it hasn’t even been attempted before.


What is complexity risk?   

 - Inertia
 - Technical Debt
 - Refactoring
 
Encapsulation:  why is it useful?  (it turns a problem of cc i*o into i+o)  also from a psychollogical perspective.   plus, city walls.



Context Switching/Locality






Hubris


lack of faith




* We would need to specify processes, and say when they ran, and how.
* Maybe all processes would communicate what they were doing with a standard protocol.
* Inputs and Outputs would need to be known
* When do processes run?
* BPMN  / XPDL are all about describing processes.  But, for me this doesn’t really cut it. 



Structure

Introduction

# Elaboration



# Variations

# Discoveries? (list of icons, definitions)


31. (Mo's Law of Evolutionary Development) You can't get to the moon by climbing successively taller trees.   http://spacecraft.ssl.umd.edu/akins_laws.html